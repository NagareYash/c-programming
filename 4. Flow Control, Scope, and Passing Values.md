## `#define` and `typedef`

### `#define`
`#define` is a **preprocessor directive** that creates a macro — a name that gets replaced by a value before compilation. It does **not** occupy memory.

**Syntax:**
```c
#define NAME value
```

**Example:**
```c
#define TRUE  1   /* make 1 TRUE  */ 
#define FALSE 0   /* make 0 FALSE */
```

By convention, macro names are written in `UPPER_CASE`.
### `typedef`
`typedef` creates a **new name (alias)** for an existing data type, making code more readable.

**Syntax:**
```c
typedef existing_type new_name;
```

**Example:**
```c
typedef int BOOLEAN;          /* BOOLEAN is now an alias for int        */
typedef unsigned char BYTE;   /* BYTE is now an alias for unsigned char */
```

**Combined usage:**
```c
#define TRUE  1
#define FALSE 0
typedef int BOOLEAN;

BOOLEAN battery_low = FALSE;  /* cleaner than writing: int battery_low = 0 */
```
## Truth Values in C
C does **not** have a built-in Boolean type. Instead, it uses **integers** to represent true and false:
- **0** = `FALSE`
- **Any non-zero value** (positive or negative) = `TRUE`

**Example:**
```c
int a = 20;

// These two are identical:
if (a != 0) {
    printf("a is true\n");
}

if (a) {
    printf("a is true\n");  // shorter, preferred way
}
```
### The `!` (NOT) Operator
The `!` operator **negates** the truth value of an expression.

```c
int a = 20;

if (!a) {
    printf("This won't print\n"); // a is non-zero (True), so !a evaluates to 0 (False)
}

if (!(a == 0)) {
    printf("This will print\n");   // a is not 0, so TRUE
}
```

### All Logical/Relational Operators Return 0 or 1

```c
int x = (5 > 3);   // x = 1 (true)
int y = (5 < 3);   // y = 0 (false)
int z = (5 == 5);  // z = 1 (true)
```

Their **chief use** is to test data and affect flow of control (in `if`, `while`, `for` etc.).
## Problem 1
Write a program in C that checks if a number is nonzero using Boolean logic. Define `TRUE` as `1` and `FALSE` as `0`, and create a `BOOLEAN` type using `typedef`. Ask the user to enter an integer, then use the number directly in an `if` condition (without `!= 0`) to check if it is nonzero.

**Expected Output:**
```shell
// Case: Non-zero number
Enter a number: 20
20 is nonzero: TRUE

// Case: Zero
Enter a number: 0
0 is nonzero: FALSE
```

**Solution**: Refer to: [non_zero.c](src/non_zero.c)
## FLAGS and Global Variables
A **flag** is a variable used to **indicate a condition or state** in your program.

**Example:**
```c
#define TRUE  1
#define FALSE 0
typedef int BOOLEAN;

BOOLEAN battery_low_FLAG = FALSE; //Initialize flag as false

// Later in code...
if (battery_level < 10) {
    battery_low_FLAG = TRUE; //Set flag once the low-battery
}

if (battery_low_FLAG) { // If flag is TRUE (1), trigger the warning
    printf("Warning: Battery low!\n");
}
```
### The Problem with Flags and Functions
When you pass a flag **by value** to a function, changes inside the function **don't affect the original** Flag variable.

**Example:**
```c
void checkBattery(BOOLEAN flag) {
    flag = TRUE;  // Only changes the local copy!
}

int main() {
    BOOLEAN battery_low_FLAG = FALSE;
    checkBattery(battery_low_FLAG);
    printf("%d\n", battery_low_FLAG);  // Still 0 (FALSE)!
}
```
### Solution: Global Variables
**Global variables** are declared **outside all functions** and are accessible from anywhere in the program.

**Placement** — after `#define` directives, before function prototypes:
```c
#include <stdio.h>
#define TRUE  1
#define FALSE 0

char test_FLAG;      /* global variable - accessible everywhere */

void swap(void);

int main() {
    test_FLAG = FALSE;
    swap();
    printf("%d\n", test_FLAG);  // Now prints 1 (TRUE)
}

void swap(void) {
    test_FLAG = TRUE;   // Modifies the global directly
}
```
## `break`, `continue`, `return`, and `goto`
These four statements cause an **unconditional change in flow of control**. Their use should be minimized.
### `break`
Immediately **exits** a loop or switch statement. Program control resumes at the next statement after the loop.
```c
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break;       // exits loop when i hits 5
    }
    printf("%d ", i);
}
// Output: 1 2 3 4
```
### `continue`
The **opposite of break** — instead of exiting, it **skips the rest of the current iteration** and forces the next one.

```c
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        continue;    // skip even numbers
    }
    printf("%d ", i);
}
// Output: 1 3 5 7 9
```
### `return`
**Exits a function** and optionally passes a value back to the caller.

```c
float minimum(float x, float y) {
    if (x < y)
        return x;   // exits function, returns x
    else
        return y;   // exits function, returns y
}
```
### `goto`
Jumps **unconditionally** to a labeled statement anywhere in the function.

**⚠️ WARNING: Avoid using `goto`.** Its only valid use in C is **error handling**.
```c
if (error_occurred) {
    goto error;     // jump to label
}

// normal code...

error:
    printf("An error occurred\n");
    return -1;
```
## Ternary Operator (`? :`)
The ternary operator is a **shorthand for a simple `if-else`** statement. It's called "ternary" because it takes **three operands**.

**Syntax:**
```c
Expression1 ? Expression2 : Expression3
```

Which means:
```c
if (Expression1)
    Expression2   // runs if TRUE
else
    Expression3   // runs if FALSE
```

### When to Use It
- Simple **one-line** decisions
- Assigning a value based on a condition
- Avoid nesting ternaries, it gets hard to read quickly

**Example:**
**Traditional `if-else`:**
```c
float min(float x, float y) {
    if (x < y)
        return x;
    else
        return y;
}
```

**Same thing with ternary:**
```c
float min(float x, float y) {
    float result;
    result = x < y ? x : y;
    return result;
}
```

```c
int a = 10, b = 20;

// Find maximum
int max = (a > b) ? a : b;        // max = 20

// Check even or odd
char *type = (a % 2 == 0) ? "Even" : "Odd";  // "Even"

// Absolute value
int x = -5;
int abs_x = (x < 0) ? -x : x;    // abs_x = 5
```
## Problem 2
Write a program that takes marks of **3 subjects** as input, calculates the **average** using the ternary operator to determine if the student **Passed or Failed** (pass average is 60 or above).

**Expected Output:**
```shell
// Case: Pass
Enter marks of 3 subjects: 75 80 90
Average: 81.67
Result: Pass

// Case: Fail
Enter marks of 3 students: 40 55 30
Average: 41.67
Result: Fail

// Case: Borderline
Enter marks of 3 subjects: 60 55 65
Average: 60.00
Result: Pass
```

**Hint:**
- Use `float` for average to get decimal values
- Calculate average as: `average = (s1 + s2 + s3) / 3.0`
## Switch Statement
The `switch` statement tests a variable against a **list of values (cases)**, cleaner than many chained `if-else if` statements.

**Syntax:**
```c
switch (variable) {
    case value1:
        // code
        break;
    case value2:
        // code
        break;
    default:
        // code if no case matches
}
```

**Example:**
```c
char grade = 'B';

switch (grade) {
    case 'A':
        printf("Excellent!\n");
        break;
    case 'B':
    case 'C':
        printf("Well done\n");
        break;
    case 'D':
        printf("You passed\n");
        break;
    case 'F':
        printf("Better try again\n");
        break;
    default:
        printf("Invalid grade\n");
}
// Output: Well done
```
### Rules
1. Expression must be an **integral type** (`int`, `char`), NOT `float` or strings
2. Case values must be **constants or literals** — not variables
3. **`break` exits** the switch — without it, execution **falls through** to the next case
4. **`default`** is optional but recommended, handles unmatched cases
5. You can have **any number** of cases
### Fall-Through (Intentional)
Sometimes fall-through is **useful** — multiple cases sharing the same code:
```c
char letter = 'A';

switch (letter) {
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U':
        printf("Vowel\n");
        break;
    default:
        printf("Consonant\n");
}
```
## Problem 3
Write a menu-driven calculator program using a `switch` statement that performs **addition, subtraction, multiplication, and division** on two numbers. The program should:

1. Ask the user to enter an operator (`+`, `-`, `*`, `/`, or `q` to quit)
2. Ask the user to enter **two numbers**
3. Use `switch` to perform the operation and print the result
4. Handle **division by zero**
5. Print `"Invalid operator"` for any other input
6. Keep running until the user enters `q` to quit

**Expected Output:**
```shell
Enter operator (+, -, *, /, q to quit): +
Enter two numbers: 10 5
10.00 + 5.00 = 15.00

Enter operator (+, -, *, /, q to quit): /
Enter two numbers: 10 0
Error: Division by zero!

Enter operator (+, -, *, /, q to quit): %
Invalid operator!

Enter operator (+, -, *, /, q to quit): q
Goodbye!
```
## Local Variables and Scope
A **local variable** is declared **inside a function** and only exists within that function. This is called its **scope**.

**Key Properties:**
- Created when the function is **called**
- Destroyed when the function **exits**
- **Not accessible** outside the function
- **Re-initialized** every time the function is called

**Example:**
```c
#include <stdio.h>

void demo();

int main() {
    int total = 1;                           // main's local variable
    printf("Total inside main: %d\n", total);

    demo();

    printf("Total inside main: %d\n", total); // still 1 — unchanged
    demo();
}

void demo() {
    int total = 10;                          // demo's own local variable
    printf("Total inside demo: %d\n", total);

    total += 2;
    printf("Total inside demo: %d\n", total);
}
```

**Output:**
```shell
Total inside main: 1
Total inside demo: 10
Total inside demo: 12
Total inside main: 1
Total inside demo: 10
Total inside demo: 12
```

Even though both `main()` and `demo()` have a variable named `total`, they are **completely separate variables** — changes in one function have **zero effect** on the other.

| Variable | Belongs To | Value After `demo()` Runs |
| -------- | ---------- | ------------------------- |
| `total`  | `main()`   | Still 1                   |
| `total`  | `demo()`   | Reset to 10 on next call  |
## Pass by Value vs Pass by Reference

### Pass by Value
When you pass a variable **by value**, the function receives a **copy**. Changes inside the function do **not** affect the original.

```c
void BadSwap(int a, int b) {
    int tmp;
    tmp = a;
    a = b;
    b = tmp;    // only swaps the copies!
}

int main() {
    int a = 1, b = 2;
    printf("Before: A=%d, B=%d\n", a, b);
    BadSwap(a, b);
    printf("After:  A=%d, B=%d\n", a, b);  // still 1, 2!
}
```
## Pass by Reference
To modify the **original** variable, pass its **memory address** using `&`. The function receives a **pointer** (`*`) to the original.

- `&a` → "address of a"
- `*pA` → "value at address pA"

```c
void Swap(int *pA, int *pB) {
    int tmp;
    tmp  = *pA;   // tmp = value at pA
    *pA  = *pB;   // value at pA = value at pB
    *pB  = tmp;   // value at pB = tmp
}

int main() {
    int a = 1, b = 2;
    printf("Before: A=%d, B=%d\n", a, b);
    Swap(&a, &b);                           // pass addresses
    printf("After:  A=%d, B=%d\n", a, b);  // now 2, 1
}
```

**Output:**
```shell
Before: A=1, B=2
After:  A=2, B=1
```

|                    | Pass by Value |  Pass by Reference  |
| :----------------: | :-----------: | :-----------------: |
|   What is passed   | Copy of value | Address of variable |
| Original modified? |      No       |         Yes         |
|       Syntax       |    func(a)    |      func(&a)       |
|   Parameter type   |     int a     |       int *a        |
## Problem 4
Write a menu-driven bank account program using a `switch` statement with the following options:
1. Deposit
2. Withdraw
3. Check Balance
4. Exit

Use **pass by reference** to modify the balance directly through `deposit()` and `withdraw()` functions. Handle **insufficient funds** on withdrawal and keep the program running until the user selects Exit.

**Function Prototypes:**
```c
void deposit(float *balance, float amount);
void withdraw(float *balance, float amount);
void checkBalance(float balance);
```

**Expected Output:**
```shell
===== Bank Menu =====
1. Deposit
2. Withdraw
3. Check Balance
4. Exit
Enter choice: 1
Enter deposit amount: $500.00
Deposit successful!
Current Balance: $1500.00

===== Bank Menu =====
1. Deposit
2. Withdraw
3. Check Balance
4. Exit
Enter choice: 2
Enter withdrawal amount: $2000.00
Error: Insufficient funds!
Current Balance: $1500.00

===== Bank Menu =====
1. Deposit
2. Withdraw
3. Check Balance
4. Exit
Enter choice: 3
Current Balance: $1500.00

===== Bank Menu =====
1. Deposit
2. Withdraw
3. Check Balance
4. Exit
Enter choice: 4
Goodbye!
```

**Hint:**
- Pass `&balance` when calling `deposit()` and `withdraw()` — use `*balance` inside the function to modify the actual value
- In `withdraw()`, check if `amount > *balance` **before** subtracting to handle insufficient funds
## Practice Tasks
1.  Write a function called `isEven()` that takes an **integer** as a parameter and uses the **bitwise AND (`&`)** operator to determine if the number is even or odd. Call the function from `main()` and print the result. **Note:** Do **not** use the modulus (`%`) operator — use only bitwise AND.
   
**Expected Output:**
```shell
// Case: Even
Enter a number: 6
6 is Even

// Case: Odd
Enter a number: 7
7 is Odd

// Case: Zero
Enter a number: 0
0 is Even
```

2. Rewrite the following `if-else` chain using a `switch` statement. Don't worry about implementing `convert_to_int()` — just include the function call.
```c
if (card_name == 'K')
    val = 13;
else if (card_name == 'Q')
    val = 12;
else if (card_name == 'J')
    val = 11;
else if (card_name == 'A')
    val = 1;
else
    val = convert_to_int(card_name);

printf("%d", val);
```

3. Write a C program that contains an **infinite loop** with an incrementing counter. Use a `break` statement to exit the loop when the counter reaches a specific value. Print the counter value on each iteration and display a message when the loop exits.
   **Expected Output:** 
```shell
Counter: 1
Counter: 2
Counter: 3
Counter: 4
Counter: 5
Loop exited at counter: 5
```
# Happy Programming!!!