## Function Prototypes
In C, a function prototype tells the compiler about a function's name, return type, and parameters before it is actually defined. This is the preferred method you should use going forward.
### Syntax
```c
return_type function_name(parameter_types);  // Prototype before main()

int main() {
    function_name(arguments);                // Call inside main()
}

return_type function_name(parameters) {      // Definition after main()
    // function body
    return value;
}
```
### Example
```c
#include <stdio.h>

int add(int, int);       // Prototype

int main() {
    int result = add(5, 10);
    printf("Sum = %d\n", result);
    return 0;
}

int add(int a, int b) {  // Definition after main
    return a + b;
}
```
### Why do we use Prototypes?
**Function prototype** provides a means for the compiler to cross-check function parameters and their data type with the function definition and the function call.
### What Happens If the Function Prototype Is Missing?
When the function prototype is missing in C, the compiler generally gives two warnings:
1. Implicit Declaration Warning.
2. Incorrect return type warning (in case where the function should return non-integer value)

The first warning shows that the compiler cannot find the function with the given name. The other warning is due to the fact that the compiler assumes the return type to be int by default in case of missing return type(or whole prototype).

**Example:**
```shell
ERROR!  
/tmp/EzfZGjMXJ4/main.c: In function 'main':  
/tmp/EzfZGjMXJ4/main.c:6:41: error: implicit declaration of function 'add' [-Wimplicit-function-declaration]  
    6 |         int result = add(5, 10);  
      |                       ^~~
```
## void Keyword
`void` means **"nothing"** or **"no value"**. It is used to explicitly tell the compiler that a function either returns nothing, takes no input, or points to no specific data type.
### Function Returns Nothing
When a function doesn't need to return a value, use `void` as the return type.

```c
void printMessage(int x) {
    printf("The value is: %d\n", x);
    // No return statement needed
}

int main() {
    printMessage(42);
    return 0;
}
```
### Function Takes No Parameters
When a function doesn't need any input, use void in the parameter list.

```c
int getValue(void) {
    return 42;
}

int main() {
    int x = getValue();
    printf("Value = %d\n", x);
    return 0;
}
```
### Void Pointers
A void pointer can hold the address of any data type. We will cover this in detail when we get to pointers.

```c
void *ptr;   // Can point to any data type
```
## Standard Library deeper dive
In C, a **header file** (`.h`) is the interface between your program and the library functions it uses. When you write `#include <stdio.h>`, you are telling the compiler to bring in all the function prototypes, data types, and macros defined in that file.
### What's Inside a Header File?
A header file can contain three things:
1. Data Types (eg. `size_t   // unsigned integral type - result of sizeof keyword`)
2. Macros  (eg. `M_PI     // value of π (3.14159...) from <math.h>`)   
3. Function Prototypes (eg. `int printf(char *format, arg1, arg2, ...);  // from stdio.h`)
### Commonly Used Header Files
| Header File  | Purpose                                         |
| ------------ | ----------------------------------------------- |
| `<stdio.h>`  | Input/output functions (`printf`, `scanf`)      |
| `<string.h>` | String functions (`strlen`, `strcmp`, `strcpy`) |
| `<math.h>`   | Math functions (`sin`, `cos`, `pow`, `sqrt`)    |
| `<ctype.h>`  | Character functions (`tolower`, `isalpha`)      |
| `<stdlib.h>` | General utilities (`malloc`, `free`, `exit`)    |
### Why Do we need header files?
- You don't need to rewrite common functions — they are already available
- You can also **create your own header files** for functions you reuse across projects
- This is the foundation of **code reusability** in C
## Fgets vs Scanf for strings
### `scanf()`

`scanf("%s", str)` reads input until it hits a **whitespace character** (space, tab, newline) and then stops.

```c
char str[50];
printf("Enter a string: ");
scanf("%s", str);
printf("You entered: %s\n", str);
```
#### Example
```shell
Enter a string: Hello World
You entered: Hello        ← stops at the space!
```

**Important Notes:**
1. No `&` needed for strings ('&’ is used to get the address of the variable. C does not have a string type, String is just an array of characters and an array variable stores the address of the first index location.)
2. By default the variable itself points to the base address and therefore to access base address of string, there is no need of adding an extra ‘&’
3. Dangerous with long input, too many characters can crash the program (buffer overflow)

### `fgets()`

`fgets(string, size, stdin)` reads up to `size - 1` characters **including spaces** and stops at a newline.

```c
char str[50];
printf("Enter a string: ");
fgets(str, 50, stdin);
printf("You entered: %s\n", str);
```

**Parameters:**
- `str` — character array to store input
- `50` — maximum characters to read (size - 1, reserves space for `\0`)
- `stdin` — standard input (keyboard)
#### Example
```shell
Enter a string: Hello World
You entered: Hello World   ← captures the full sentence!
```
## Problem 1
Write a C program that prompts the user to enter three numbers between 1 and 9. For each number, check if it is:
- Greater than 1 (`> 1`)  
- Less than 9 (`< 9`)
- Equal to 1 (`== 1`)
- Equal to 9 (`== 9`)
Display the appropriate message for each condition.

**Sample Output:**
```shell
Number 1 (1):
  - Is less than 9
  - Is equal to 1

Number 2 (5):
  - Is greater than 1
  - Is less than 9

Number 3 (9):
  - Is greater than 1
  - Is equal to 9
```
## Assignment Operators
Assignment operators are **shortcuts** that combine an arithmetic or bitwise operation with assignment in a single step.

Instead of writing `a = a + 5` you can simply write `a += 5`.
### Arithmetic Assignment Operators
| Operator | Meaning             | Example  | Equivalent  |
| -------- | ------------------- | -------- | ----------- |
| `=`      | Assign              | `a = 5`  | `a = 5`     |
| `+=`     | Add and assign      | `a += 3` | `a = a + 3` |
| `-=`     | Subtract and assign | `a -= 2` | `a = a - 2` |
| `*=`     | Multiply and assign | `a *= 4` | `a = a * 4` |
| `/=`     | Divide and assign   | `a /= 2` | `a = a / 2` |
| `%=`     | Modulus and assign  | `a %= 3` | `a = a % 3` |
### Bitwise Assignment Operators
| Operator | Meaning                | Example   | Equivalent   |
| -------- | ---------------------- | --------- | ------------ |
| `&=`     | Bitwise AND and assign | `a &= b`  | `a = a & b`  |
| `\|=`    | Bitwise OR and assign  | `a \|= b` | `a = a \| b` |
| `^=`     | Bitwise XOR and assign | `a ^= b`  | `a = a ^ b`  |
| `<<=`    | Left shift and assign  | `a <<= 1` | `a = a << 1` |
| `>>=`    | Right shift and assign | `a >>= 1` | `a = a >> 1` |
### Example
```c
#include <stdio.h>

int main() {
    int a = 10;

    a += 5;   printf("a += 5  → %d\n", a);   // 15
    a -= 3;   printf("a -= 3  → %d\n", a);   // 12
    a *= 2;   printf("a *= 2  → %d\n", a);   // 24
    a /= 4;   printf("a /= 4  → %d\n", a);   // 6
    a %= 4;   printf("a %%= 4  → %d\n", a);  // 2

    return 0;
}
```

**Output:**
```shell
a += 5  → 15
a -= 3  → 12
a *= 2  → 24
a /= 4  → 6
a %= 4  → 2
```
## Logical Operators
Logical operators are used to **combine multiple conditions** together. They work with the TRUE/FALSE values we just learned about.
### Three Logical Operators
| Operator          | Name | Description                                |
| ----------------- | ---- | ------------------------------------------ |
| `!`               | NOT  | Reverses the condition                     |
| `&&`              | AND  | TRUE only if **both** conditions are TRUE  |
| <code>\|\|</code> | OR   | TRUE if **at least one** condition is TRUE |
#### `!` NOT Operator
Flips TRUE to FALSE and FALSE to TRUE.
```c
int x = 5;

if (!x) {
    printf("This won't print\n");   // x is TRUE, !x is FALSE
}

if (!(x == 10)) {
    printf("x is not 10\n");        // prints this
}
```
#### `&&` AND Operator
Both conditions **must** be TRUE.
```c
int age = 20;
int hasLicense = 1;

if (age >= 18 && hasLicense) {
    printf("Can drive\n");    // prints this - both are TRUE
}
```
##### Truth Table:
| A   | B   | A && B |
| --- | --- | ------ |
| 0   | 0   | 0      |
| 0   | 1   | 0      |
| 1   | 0   | 0      |
| 1   | 1   | 1      |
#### `||` OR Operator
At least **one** condition must be TRUE.
```c
int isWeekend = 0;
int isHoliday = 1;

if (isWeekend || isHoliday) {
    printf("Day off!\n");    // prints this - one is TRUE
}
```
##### Truth Table:
| A   | B   | A \| B |
| --- | --- | ------ |
| 0   | 0   | 0      |
| 0   | 1   | 1      |
| 1   | 0   | 1      |
| 1   | 1   | 1      |
### Combining Logical Operators
```c
int age = 25;
int salary = 50000;
int hasDebt = 0;

if (age >= 18 && salary >= 30000 && !hasDebt) {
    printf("Loan approved!\n");   // all three conditions met
}
```

## Problem 2
Write a C program that takes a user's age, income, and FICO score as input and checks if the person is eligible for a bank loan. If the income is insufficient for a direct loan, ask if there is an individual who can co-sign for the loan.

**Eligibility Criteria:**
- Age must be **21 or older**
- Income must be **above $10,000**
- FICO score must be **greater than or equal to 700**

**Sample Output:**
```shell
Enter your age: 25
Enter your income: 8000
Enter your FICO score: 720

Income is insufficient for a direct loan.
Do you have a co-signer? (1 = Yes, 0 = No): 1
Loan Approved with co-signer!
```

**Hint:** Make use of logical operators (`&&`, `||`, `!`)

## Bitwise Operators
Bitwise operators work directly on the **individual bits** of a variable, not the whole value. To understand them, you need to think in **binary (0s and 1s)**.
```c
Eg.
	Decimal 1  =  Binary 00000001
	Decimal 3  =  Binary 00000011
	Decimal 5  =  Binary 00000101
	Decimal 8  =  Binary 00001000
```
### Six Bitwise Operators
| Operator        | Name        | Description                           |
| --------------- | ----------- | ------------------------------------- |
| `&`             | AND         | Bit is 1 only if **both** bits are 1  |
| <code>\|</code> | OR          | Bit is 1 if **at least one** bit is 1 |
| `^`             | XOR         | Bit is 1 if bits are **different**    |
| `~`             | NOT         | **Flips** all bits                    |
| `<<`            | Left Shift  | Shifts bits left (multiply by 2)      |
| `>>`            | Right Shift | Shifts bits right (divide by 2)       |
#### `&` Bitwise AND
```c
5 = 00000101  
3 = 00000011  
&  ---------  
1 = 00000001
```

```c
printf("%d\n", 5 & 3);   // Output: 1
```
#### `|` Bitwise OR
```c
5 = 00000101  
3 = 00000011  
|  ---------  
7 = 00000111
```

```c
printf("%d\n", 5 | 3);   // Output: 7
```
#### `^` Bitwise XOR
```c
5 = 00000101  
3 = 00000011  
^  ---------  
6 = 00000110
```

```c
printf("%d\n", 5 ^ 3);   // Output: 6
```
#### `~` Bitwise NOT
```c
5 = 00000101  
~  ---------    
  = 11111010  → -6 (in two's complement)
```

```c
printf("%d\n", ~5);   // Output: -6
```
#### `<<` Left Shift
```c
     8 = 00001000  
8 << 2  --------- 
    32 = 00100000   (shifted 2 positions left)
```

```c
printf("%d\n", 8 << 2);   // Output: 32 
printf("%d\n", 8 << 1);   // Output: 16  (8 × 2)
```
#### `>>` Right Shift
```c
     8 = 00001000  
8 >> 2  ---------  
     2 = 00000010   (shifted 2 positions right)
```

```c
printf("%d\n", 8 >> 2);   // Output: 2 
printf("%d\n", 8 >> 1);   // Output: 4  (8 ÷ 2)
```
### Example
```c
#include <stdio.h>

int main() {
    int a = 5, b = 3;

    printf("a & b  = %d\n", a & b);    // AND:   1
    printf("a | b  = %d\n", a | b);    // OR:    7
    printf("a ^ b  = %d\n", a ^ b);    // XOR:   6
    printf("~a     = %d\n", ~a);       // NOT:  -6
    printf("a << 1 = %d\n", a << 1);   // LEFT:  10
    printf("a >> 1 = %d\n", a >> 1);   // RIGHT: 2

    return 0;
}
```

**Output:**
```shell
a & b  = 1
a | b  = 7
a ^ b  = 6
~a     = -6
a << 1 = 10
a >> 1 = 2
```
## Problem 3
Given an unsigned char with bits `11010011` (where bit 0 is the rightmost bit and bit 7 is the leftmost bit):
```c
Bit position:  7  6  5  4  3  2  1  0
Bit value:     1  1  0  1  0  0  1  1
```

Write a C program to:
- **Flip bit 1** from `1` to `0`
- **Flip bit 5** from `0` to `1`
Leave all other bits unchanged.

**Sample Output:**
```shell
Original value:  11010011
Modified value:  11110001
```

**Hint:** XOR with `1` flips a bit. Use left shift (`<<`) to target the specific bit position.

**Helper function:**
```c
void print_binary(unsigned char x)
{
    for (int i = 7; i >= 0; i--) {
        if ( (x >> i) & 1 )
            printf("1");
        else
            printf("0");
    }
}
```
## Increment/Decrement Operators
Increment (`++`) and decrement (`--`) operators **increase or decrease a variable's value by 1**. The key difference is **where** you place the operator — before or after the variable.
### Types
| Operator | Name           | Effect                               |
| -------- | -------------- | ------------------------------------ |
| `++a`    | Pre-increment  | Increment by 1 **then** return value |
| `a++`    | Post-increment | Return value **then** increment by 1 |
| `--a`    | Pre-decrement  | Decrement by 1 **then** return value |
| `a--`    | Post-decrement | Return value **then** decrement by 1 |
## Example

```c
#include <stdio.h>

int main() {
    int a = 5, b;

    // Post-increment
    b = a++;
    printf("Post-increment: b = %d, a = %d\n", b, a);  // b=5, a=6

    // Pre-increment
    b = ++a;
    printf("Pre-increment:  b = %d, a = %d\n", b, a);  // b=7, a=7

    // Post-decrement
    b = a--;
    printf("Post-decrement: b = %d, a = %d\n", b, a);  // b=7, a=6

    // Pre-decrement
    b = --a;
    printf("Pre-decrement:  b = %d, a = %d\n", b, a);  // b=5, a=5

    return 0;
}
```

**Output:**
```shell
Post-increment: b = 5, a = 6
Pre-increment:  b = 7, a = 7
Post-decrement: b = 7, a = 6
Pre-decrement:  b = 5, a = 5
```

**Commonly used in Loops**
```c
for (int i = 0; i < 5; i++) {    // i++ most common in loops
    printf("%d ", i);
}
// Output: 0 1 2 3 4
```

**Hint:** In a simple loop, `i++` and `++i` produce the same result. The difference only matters when the value is used in an expression like `b = a++`.
## TRUE/FALSE in C
Unlike other languages, C does **not** have a built-in boolean type (no `true` or `false` keywords in basic C). Instead, C uses **integer values** to represent logical conditions.
### The Rule
- Any **non-zero** value = **TRUE**
- **Zero** (0) = **FALSE**
### Example
```c
#include <stdio.h>

int main() {
    int x = 0;
    int y = 7;
    int z = -3;   // negative numbers are also TRUE!

    if (x)
        printf("x is TRUE\n");
    else
        printf("x is FALSE\n");   // prints this

    if (y)
        printf("y is TRUE\n");    // prints this
    else
        printf("y is FALSE\n");

    if (z)
        printf("z is TRUE\n");    // prints this - negative is also TRUE!
    else
        printf("z is FALSE\n");

    return 0;
}
```

**Output:**
```shell
x is FALSE
y is TRUE
z is TRUE
```
### How it Works with Conditions
When you use a relational operator like `==` or `>`, it returns:
- **1** if the condition is TRUE
- **0** if the condition is FALSE
##  Sizeof Operator
`sizeof()` is a **compile-time operator** that returns the size (in bytes) of a data type or variable. It is useful when you need to know how much memory is being used.
### Syntax
```c
sizeof(data_type)    // with a type
sizeof(variable)     // with a variable
```
### Size of Basic Data Types
```c
#include <stdio.h>

int main() {
    printf("char:        %lu bytes\n", sizeof(char));
    printf("short:       %lu bytes\n", sizeof(short));
    printf("int:         %lu bytes\n", sizeof(int));
    printf("long:        %lu bytes\n", sizeof(long));
    printf("float:       %lu bytes\n", sizeof(float));
    printf("double:      %lu bytes\n", sizeof(double));
    printf("long double: %lu bytes\n", sizeof(long double));
    return 0;
}
```

**Output:**
```shell
char:        1 bytes
short:       2 bytes
int:         4 bytes
long:        8 bytes
float:       4 bytes
double:      8 bytes
long double: 16 bytes
```
### Size of Variables and Arrays
```c
#include <stdio.h>

int main() {
    int x = 10;
    int arr[10];

    printf("Size of x:   %lu bytes\n", sizeof(x));      // 4
    printf("Size of arr: %lu bytes\n", sizeof(arr));     // 40 (10 × 4)

    return 0;
}
```

**Output:**
```shell
Size of x:   4 bytes
Size of arr: 40 bytes
```
## Formatted Output (`printf()`)
printf gives you precise control over how your output looks using format specifiers. You can control width, alignment, decimal places, and more.
### Format Specifier Structure
```c
%[flag][width][.precision]specifier
```

|Part|Purpose|
|---|---|
|`flag`|Controls alignment, sign, padding|
|`width`|Minimum number of characters to display|
|`.precision`|Decimal places for floats, max characters for strings|
|`specifier`|Data type (`d`, `f`, `s`, `c`, etc.)|
### Flags
|Flag|Meaning|Example|
|---|---|---|
|`-`|Left justify|`%-10d`|
|`+`|Always show sign|`%+d`|
|`0`|Pad with zeros|`%05d`|
|`#`|Alternate form|`%#x`|
#### Width and Precision Examples
```c
#include <stdio.h>

int main() {
    int x = 42;
    float pi = 3.14159;
    char name[] = "Alice";

    // Width with integers
    printf("[%5d]\n", x);       // [   42]  right justified
    printf("[%-5d]\n", x);      // [42   ]  left justified
    printf("[%05d]\n", x);      // [00042]  zero padded
    printf("[%+d]\n", x);       // [+42]    show sign

    // Width and precision with floats
    printf("[%10.3f]\n", pi);   // [     3.142]  width 10, 3 decimals
    printf("[%-10.3f]\n", pi);  // [3.142     ]  left justified

    // Width and precision with strings
    printf("[%10s]\n", name);   // [     Alice]  right justified
    printf("[%-10s]\n", name);  // [Alice     ]  left justified
    printf("[%.3s]\n", name);   // [Ali]         only 3 characters

    return 0;
}
```
### `#` Modifier
| Format | Effect                    | Example Output |
| ------ | ------------------------- | -------------- |
| `%#o`  | Adds leading `0` to octal | `010`          |
| `%#x`  | Adds leading `0x` to hex  | `0xff`         |
| `%#f`  | Forces decimal point      | `3.000000`     |
```c
printf("%#o\n", 8);    // 010
printf("%#x\n", 255);  // 0xff
printf("%#f\n", 3.0);  // 3.000000
```
## Problem 4
Write a C program that reads a floating-point number from the user and prints it in three different formats:
1. 2 decimal places
2. Right-aligned in a 10-character space
3. Left-aligned with a visible sign (`+` or `-`)
**Hint:** Combine flags, width, and precision in a single format specifier!

**Sample Output:**
```shell
Enter a floating-point number: 3.14159
2 decimal places:          3.14
Right-aligned (10 chars):        3.14
Left-aligned with sign:    +3.14
```
# Happy Programming!!!